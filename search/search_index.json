{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AIOAPI \u00b6 AIOAPI is a library for building APIs with AIOHTTP framework and Python 3.7+ based on standard Python type hints. Install \u00b6 Just: 1 $ pip install aioapi Requirements \u00b6 AIOAPI depends on AIOHTTP framework and tries to extend the view layer in the right way, also AIOAPI depends on pydantic \u2014 a great data validation library. At a glance \u00b6 Look at simple application below and pay attention to the highlighted lines to see the power of AIOAPI : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from http import HTTPStatus from uuid import UUID import aioapi as api from aioapi import Body , PathParam from aiohttp import web from pydantic import BaseModel class Database : async def get_user ( self , * , user_id ): ... async def create_user ( self , * , user_id , name , age ): ... class User ( BaseModel ): user_id : UUID name : string age : int = 42 async def get_user ( app : web . Application , user_id : PathParam [ UUID ]): user = await app [ \"db\" ] . get_user ( user_id = user_id ) return web . json_response ( { \"user_id\" : user . user_id , \"name\" : user . name , \"age\" : user . age } ) async def create_user ( app : web . Application , body : Body [ User ]) user = body . cleaned await app [ \"db\" ] . create_user ( user_id = user . user_id , name = user . name , age = user . age ) return web . Response ( status = HTTPStatus . CREATED ) def main (): app = web . Application () app [ \"db\" ] = Database () app . add_routes ([ api . post ( \"/users\" , create_user ), api . get ( \"/users/{user_id}\" , get_user ), ]) web . run_app ( app ) if __name__ == \"__main__\" : main () That simple example shows you how AIOAPI can help you to simplify your daily routine with data serialization and validation in APIs. As you can see you need just to define the right types and AIOAPI will do all other job for you. Looks interesting for you? Go ahead and explore documentation, AIOAPI can surprise you!","title":"Home"},{"location":"#aioapi","text":"AIOAPI is a library for building APIs with AIOHTTP framework and Python 3.7+ based on standard Python type hints.","title":"AIOAPI"},{"location":"#install","text":"Just: 1 $ pip install aioapi","title":"Install"},{"location":"#requirements","text":"AIOAPI depends on AIOHTTP framework and tries to extend the view layer in the right way, also AIOAPI depends on pydantic \u2014 a great data validation library.","title":"Requirements"},{"location":"#at-a-glance","text":"Look at simple application below and pay attention to the highlighted lines to see the power of AIOAPI : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from http import HTTPStatus from uuid import UUID import aioapi as api from aioapi import Body , PathParam from aiohttp import web from pydantic import BaseModel class Database : async def get_user ( self , * , user_id ): ... async def create_user ( self , * , user_id , name , age ): ... class User ( BaseModel ): user_id : UUID name : string age : int = 42 async def get_user ( app : web . Application , user_id : PathParam [ UUID ]): user = await app [ \"db\" ] . get_user ( user_id = user_id ) return web . json_response ( { \"user_id\" : user . user_id , \"name\" : user . name , \"age\" : user . age } ) async def create_user ( app : web . Application , body : Body [ User ]) user = body . cleaned await app [ \"db\" ] . create_user ( user_id = user . user_id , name = user . name , age = user . age ) return web . Response ( status = HTTPStatus . CREATED ) def main (): app = web . Application () app [ \"db\" ] = Database () app . add_routes ([ api . post ( \"/users\" , create_user ), api . get ( \"/users/{user_id}\" , get_user ), ]) web . run_app ( app ) if __name__ == \"__main__\" : main () That simple example shows you how AIOAPI can help you to simplify your daily routine with data serialization and validation in APIs. As you can see you need just to define the right types and AIOAPI will do all other job for you. Looks interesting for you? Go ahead and explore documentation, AIOAPI can surprise you!","title":"At a glance"},{"location":"release_notes/","text":"Release Notes \u00b6 Next release \u00b6 Add cookie parameters support. Add header parameters support. Add response body support. Add nested components support. Add RouteTableDef support. Add benchmarks. 0.2.0 \u00b6 [backward incompatible] Rename project to aioapi . Add path parameters support. Add query parameters support. Add request body support. Support class-based views. Allow to define bad request handler.","title":"Release Notes"},{"location":"release_notes/#release-notes","text":"","title":"Release Notes"},{"location":"release_notes/#next-release","text":"Add cookie parameters support. Add header parameters support. Add response body support. Add nested components support. Add RouteTableDef support. Add benchmarks.","title":"Next release"},{"location":"release_notes/#020","text":"[backward incompatible] Rename project to aioapi . Add path parameters support. Add query parameters support. Add request body support. Support class-based views. Allow to define bad request handler.","title":"0.2.0"},{"location":"tutorial/components/","text":"Components \u00b6 AIOAPI supports components which you can use in your views, using standard Python type annotations. Supported components: aiohttp.web.Request aiohttp.web.Application Below you can find a real example of request and application components usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import aioapi as api from aiohttp import web async def hello_components ( request : web . Request , app : web . Application ): return web . Response () def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello_components\" , hello_components )]) web . run_app ( app ) if __name__ == \"__main__\" : main ()","title":"Components"},{"location":"tutorial/components/#components","text":"AIOAPI supports components which you can use in your views, using standard Python type annotations. Supported components: aiohttp.web.Request aiohttp.web.Application Below you can find a real example of request and application components usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import aioapi as api from aiohttp import web async def hello_components ( request : web . Request , app : web . Application ): return web . Response () def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello_components\" , hello_components )]) web . run_app ( app ) if __name__ == \"__main__\" : main ()","title":"Components"},{"location":"tutorial/data_validation/","text":"Data Validation \u00b6 AIOAPI relies on pydantic for data validation. To know how to work with pydantic and to get know all about its features please follow official documentation . Below you can find a simple example of pydantic s model declaration: 1 2 3 4 5 6 7 8 9 10 11 from datetime import datetime from typing import List from pydantic import BaseModel class User ( BaseModel ): id : int name = 'John Doe' signup_ts : datetime = None friends : List [ int ] = []","title":"Data Validation"},{"location":"tutorial/data_validation/#data-validation","text":"AIOAPI relies on pydantic for data validation. To know how to work with pydantic and to get know all about its features please follow official documentation . Below you can find a simple example of pydantic s model declaration: 1 2 3 4 5 6 7 8 9 10 11 from datetime import datetime from typing import List from pydantic import BaseModel class User ( BaseModel ): id : int name = 'John Doe' signup_ts : datetime = None friends : List [ int ] = []","title":"Data Validation"},{"location":"tutorial/handling_errors/","text":"Handling Errors \u00b6 AIOAPI by default returns empty 400 Bad Request response in case of any validation error. If you run example below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import aioapi as api from aioapi import QueryParam from aiohttp import web async def hello_errors ( name : QueryParam [ str ]): return web . Response () def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello_errors\" , hello_errors )]) web . run_app ( app ) if __name__ == \"__main__\" : main () And send request to /hello_errors route you will see: 1 2 3 4 5 6 7 8 $ http :8080/hello_errors HTTP/1.1 400 Bad Request Content-Length: 16 Content-Type: text/plain ; charset = utf-8 Date: Fri, 12 Apr 2019 20 :24:50 GMT Server: Python/3.7 aiohttp/3.5.4 400 : Bad Request To get more fancy 400 Bad Request response you can use validation_error_middleware middleware: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import aioapi as api from aioapi import QueryParam from aioapi.middlewares import validation_error_middleware from aiohttp import web async def hello_errors ( name : QueryParam [ str ]): return web . Response () def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello_errors\" , hello_errors )]) app . middlewares . append ( validation_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () If you send a request to /hello_errors route you will see an error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ http :8080/hello_errors HTTP/1.1 400 Bad Request Content-Length: 185 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 20 :31:49 GMT Server: Python/3.7 aiohttp/3.5.4 { \"invalid_params\" : [ { \"loc\" : [ \"query\" , \"name\" ] , \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } ] , \"title\" : \"Your request parameters didn't validate.\" , \"type\" : \"validation_error\" } And also you can write your own middleware to handle validation errors: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import json import aioapi as api from aioapi import QueryParam from aioapi.exceptions import HTTPBadRequest from aiohttp import web async def hello_errors ( name : QueryParam [ str ]): return web . Response () @web.middleware async def custom_error_middleware ( request , handler ): try : resp = await handler ( request ) except HTTPBadRequest as e : raise web . HTTPBadRequest ( content_type = \"application/json\" , text = json . dumps ( e . validation_error . errors ()), ) return resp def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello_errors\" , hello_errors )]) app . middlewares . append ( custom_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () If you send a request to /hello_errors route you will see an error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ http :8080/hello_errors HTTP/1.1 400 Bad Request Content-Length: 84 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 20 :34:56 GMT Server: Python/3.7 aiohttp/3.5.4 [ { \"loc\" : [ \"query\" , \"name\" ] , \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } ]","title":"Handling Errors"},{"location":"tutorial/handling_errors/#handling-errors","text":"AIOAPI by default returns empty 400 Bad Request response in case of any validation error. If you run example below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import aioapi as api from aioapi import QueryParam from aiohttp import web async def hello_errors ( name : QueryParam [ str ]): return web . Response () def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello_errors\" , hello_errors )]) web . run_app ( app ) if __name__ == \"__main__\" : main () And send request to /hello_errors route you will see: 1 2 3 4 5 6 7 8 $ http :8080/hello_errors HTTP/1.1 400 Bad Request Content-Length: 16 Content-Type: text/plain ; charset = utf-8 Date: Fri, 12 Apr 2019 20 :24:50 GMT Server: Python/3.7 aiohttp/3.5.4 400 : Bad Request To get more fancy 400 Bad Request response you can use validation_error_middleware middleware: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import aioapi as api from aioapi import QueryParam from aioapi.middlewares import validation_error_middleware from aiohttp import web async def hello_errors ( name : QueryParam [ str ]): return web . Response () def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello_errors\" , hello_errors )]) app . middlewares . append ( validation_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () If you send a request to /hello_errors route you will see an error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ http :8080/hello_errors HTTP/1.1 400 Bad Request Content-Length: 185 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 20 :31:49 GMT Server: Python/3.7 aiohttp/3.5.4 { \"invalid_params\" : [ { \"loc\" : [ \"query\" , \"name\" ] , \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } ] , \"title\" : \"Your request parameters didn't validate.\" , \"type\" : \"validation_error\" } And also you can write your own middleware to handle validation errors: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import json import aioapi as api from aioapi import QueryParam from aioapi.exceptions import HTTPBadRequest from aiohttp import web async def hello_errors ( name : QueryParam [ str ]): return web . Response () @web.middleware async def custom_error_middleware ( request , handler ): try : resp = await handler ( request ) except HTTPBadRequest as e : raise web . HTTPBadRequest ( content_type = \"application/json\" , text = json . dumps ( e . validation_error . errors ()), ) return resp def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello_errors\" , hello_errors )]) app . middlewares . append ( custom_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () If you send a request to /hello_errors route you will see an error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ http :8080/hello_errors HTTP/1.1 400 Bad Request Content-Length: 84 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 20 :34:56 GMT Server: Python/3.7 aiohttp/3.5.4 [ { \"loc\" : [ \"query\" , \"name\" ] , \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } ]","title":"Handling Errors"},{"location":"tutorial/intro/","text":"Intro \u00b6 This tutorial shows you how to use AIOAPI with all its features, step by step. Install AIOAPI \u00b6 Install AIOAPI : 1 $ pip install aioapi First Steps \u00b6 Create simple AIOHTTP application, during tutorial we will extend it step by step: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import aioapi as api from aioapi.middlewares import validation_error_middleware from aiohttp import web async def hello_aioapi (): return web . json_response ({ \"hello\" : \"AIOAPI\" }) def main (): app = web . Application () app . add_routes ([ api . get ( \"/\" , hello_aioapi )]) app . middlewares . append ( validation_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () Copy that to a file main.py and run the live server: 1 $ python main.py Open browser at http://127.0.0.1:8080 or use command line tool like cURL or HTTPie to check that server is up and running: 1 2 3 4 5 6 7 8 9 10 $ http :8080 HTTP/1.1 200 OK Content-Length: 19 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 17 :44:31 GMT Server: Python/3.7 aiohttp/3.5.4 { \"hello\" : \"AIOAPI\" } Examples \u00b6 You can also skip the tutorial and jump into examples/ directory where you can find an example application which shows all power of AIOAPI library.","title":"Intro"},{"location":"tutorial/intro/#intro","text":"This tutorial shows you how to use AIOAPI with all its features, step by step.","title":"Intro"},{"location":"tutorial/intro/#install-aioapi","text":"Install AIOAPI : 1 $ pip install aioapi","title":"Install AIOAPI"},{"location":"tutorial/intro/#first-steps","text":"Create simple AIOHTTP application, during tutorial we will extend it step by step: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import aioapi as api from aioapi.middlewares import validation_error_middleware from aiohttp import web async def hello_aioapi (): return web . json_response ({ \"hello\" : \"AIOAPI\" }) def main (): app = web . Application () app . add_routes ([ api . get ( \"/\" , hello_aioapi )]) app . middlewares . append ( validation_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () Copy that to a file main.py and run the live server: 1 $ python main.py Open browser at http://127.0.0.1:8080 or use command line tool like cURL or HTTPie to check that server is up and running: 1 2 3 4 5 6 7 8 9 10 $ http :8080 HTTP/1.1 200 OK Content-Length: 19 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 17 :44:31 GMT Server: Python/3.7 aiohttp/3.5.4 { \"hello\" : \"AIOAPI\" }","title":"First Steps"},{"location":"tutorial/intro/#examples","text":"You can also skip the tutorial and jump into examples/ directory where you can find an example application which shows all power of AIOAPI library.","title":"Examples"},{"location":"tutorial/path_parameters/","text":"Path Parameters \u00b6 You can declare path parameters and their types, using standard Python type annotations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import aioapi as api from aioapi import PathParam from aioapi.middlewares import validation_error_middleware from aiohttp import web async def hello_path ( number : PathParam [ int ]): return web . json_response ({ \"hello\" , number . cleaned }) def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello/{number}\" , hello_path )]) app . middlewares . append ( validation_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () If you run this example and send a request to /hello/42 route you will see: 1 2 3 4 5 6 7 8 9 10 $ http :8080/hello/42 HTTP/1.1 200 OK Content-Length: 13 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :18:54 GMT Server: Python/3.7 aiohttp/3.5.4 { \"hello\" : 42 } But if you send a request to /hello/batman route you will see an error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ http :8080/hello/batman HTTP/1.1 400 Bad Request Content-Length: 199 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :20:44 GMT Server: Python/3.7 aiohttp/3.5.4 { \"invalid_params\" : [ { \"loc\" : [ \"path\" , \"number\" ] , \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] , \"title\" : \"Your request parameters didn't validate.\" , \"type\" : \"validation_error\" }","title":"Path Parameters"},{"location":"tutorial/path_parameters/#path-parameters","text":"You can declare path parameters and their types, using standard Python type annotations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import aioapi as api from aioapi import PathParam from aioapi.middlewares import validation_error_middleware from aiohttp import web async def hello_path ( number : PathParam [ int ]): return web . json_response ({ \"hello\" , number . cleaned }) def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello/{number}\" , hello_path )]) app . middlewares . append ( validation_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () If you run this example and send a request to /hello/42 route you will see: 1 2 3 4 5 6 7 8 9 10 $ http :8080/hello/42 HTTP/1.1 200 OK Content-Length: 13 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :18:54 GMT Server: Python/3.7 aiohttp/3.5.4 { \"hello\" : 42 } But if you send a request to /hello/batman route you will see an error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ http :8080/hello/batman HTTP/1.1 400 Bad Request Content-Length: 199 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :20:44 GMT Server: Python/3.7 aiohttp/3.5.4 { \"invalid_params\" : [ { \"loc\" : [ \"path\" , \"number\" ] , \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] , \"title\" : \"Your request parameters didn't validate.\" , \"type\" : \"validation_error\" }","title":"Path Parameters"},{"location":"tutorial/query_parameters/","text":"Query Parameters \u00b6 You can declare query parameters and their types, using standard Python type annotations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import aioapi as api from aioapi import QueryParam from aioapi.middlewares import validation_error_middleware from aiohttp import web async def hello_query ( name : QueryParam [ str ]): return web . json_response ({ \"name\" : name . cleaned }) def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello_query\" , hello_query )]) app . middlewares . append ( validation_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () Query parameters can have default values: 1 2 3 4 5 6 7 8 async def hello_query ( name : QueryParam [ str ], age : QueryParam [ int ] = QueryParam ( 42 ), ): return web . json_response ({ \"name\" : name . cleaned , \"age\" : age . cleaned , }) If you run this example and send a request to /hello_query?name=batman route you will see: 1 2 3 4 5 6 7 8 9 10 11 $ http :8080/hello_query?name = batman HTTP/1.1 200 OK Content-Length: 30 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :29:18 GMT Server: Python/3.7 aiohttp/3.5.4 { \"age\" : 42 , \"name\" : \"batman\" } But if you send a request to /hello_query route you will see an error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ http :8080/hello_query HTTP/1.1 400 Bad Request Content-Length: 185 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :33:45 GMT Server: Python/3.7 aiohttp/3.5.4 { \"invalid_params\" : [ { \"loc\" : [ \"query\" , \"name\" ] , \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } ] , \"title\" : \"Your request parameters didn't validate.\" , \"type\" : \"validation_error\" }","title":"Query Parameters"},{"location":"tutorial/query_parameters/#query-parameters","text":"You can declare query parameters and their types, using standard Python type annotations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import aioapi as api from aioapi import QueryParam from aioapi.middlewares import validation_error_middleware from aiohttp import web async def hello_query ( name : QueryParam [ str ]): return web . json_response ({ \"name\" : name . cleaned }) def main (): app = web . Application () app . add_routes ([ api . get ( \"/hello_query\" , hello_query )]) app . middlewares . append ( validation_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () Query parameters can have default values: 1 2 3 4 5 6 7 8 async def hello_query ( name : QueryParam [ str ], age : QueryParam [ int ] = QueryParam ( 42 ), ): return web . json_response ({ \"name\" : name . cleaned , \"age\" : age . cleaned , }) If you run this example and send a request to /hello_query?name=batman route you will see: 1 2 3 4 5 6 7 8 9 10 11 $ http :8080/hello_query?name = batman HTTP/1.1 200 OK Content-Length: 30 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :29:18 GMT Server: Python/3.7 aiohttp/3.5.4 { \"age\" : 42 , \"name\" : \"batman\" } But if you send a request to /hello_query route you will see an error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ http :8080/hello_query HTTP/1.1 400 Bad Request Content-Length: 185 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :33:45 GMT Server: Python/3.7 aiohttp/3.5.4 { \"invalid_params\" : [ { \"loc\" : [ \"query\" , \"name\" ] , \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } ] , \"title\" : \"Your request parameters didn't validate.\" , \"type\" : \"validation_error\" }","title":"Query Parameters"},{"location":"tutorial/request_body/","text":"Request Body \u00b6 You can declare a request body and its type, using standard Python type annotations. The request body, as well as query parameters, can be defined with a default value. To declare body type use pydantic models. And you can always combine and use path and query parameters, and request body in one view. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import aioapi as api from aioapi import Body , PathParam from aioapi.middlewares import validation_error_middleware from aiohttp import web from pydantic import BaseModel class User ( BaseModel ): name : str age : int = 42 async def hello_body ( user_id : PathParam [ int ], body : Body [ User ]): user = body . cleaned return web . json_response ( { \"id\" : user_id . cleaned , \"name\" : user . name , \"age\" : user . age } ) def main (): app = web . Application () app . add_routes ([ api . post ( \"/hello/{user_id}\" , hello_body )]) app . middlewares . append ( validation_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () If you run this example and send a request to /hello/42 route you will see: 1 2 3 4 5 6 7 8 9 10 11 12 $ http :8080/hello/42 name = batman HTTP/1.1 200 OK Content-Length: 39 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :56:47 GMT Server: Python/3.7 aiohttp/3.5.4 { \"age\" : 42 , \"id\" : 42 , \"name\" : \"batman\" } But if you send a request to /hello/batman route you will see an error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 $ http :8080/hello/batman age = random HTTP/1.1 400 Bad Request Content-Length: 378 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :57:49 GMT Server: Python/3.7 aiohttp/3.5.4 { \"invalid_params\" : [ { \"loc\" : [ \"body\" , \"name\" ] , \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } , { \"loc\" : [ \"body\" , \"age\" ] , \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } , { \"loc\" : [ \"path\" , \"user_id\" ] , \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] , \"title\" : \"Your request parameters didn't validate.\" , \"type\" : \"validation_error\" }","title":"Request Body"},{"location":"tutorial/request_body/#request-body","text":"You can declare a request body and its type, using standard Python type annotations. The request body, as well as query parameters, can be defined with a default value. To declare body type use pydantic models. And you can always combine and use path and query parameters, and request body in one view. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import aioapi as api from aioapi import Body , PathParam from aioapi.middlewares import validation_error_middleware from aiohttp import web from pydantic import BaseModel class User ( BaseModel ): name : str age : int = 42 async def hello_body ( user_id : PathParam [ int ], body : Body [ User ]): user = body . cleaned return web . json_response ( { \"id\" : user_id . cleaned , \"name\" : user . name , \"age\" : user . age } ) def main (): app = web . Application () app . add_routes ([ api . post ( \"/hello/{user_id}\" , hello_body )]) app . middlewares . append ( validation_error_middleware ) web . run_app ( app ) if __name__ == \"__main__\" : main () If you run this example and send a request to /hello/42 route you will see: 1 2 3 4 5 6 7 8 9 10 11 12 $ http :8080/hello/42 name = batman HTTP/1.1 200 OK Content-Length: 39 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :56:47 GMT Server: Python/3.7 aiohttp/3.5.4 { \"age\" : 42 , \"id\" : 42 , \"name\" : \"batman\" } But if you send a request to /hello/batman route you will see an error: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 $ http :8080/hello/batman age = random HTTP/1.1 400 Bad Request Content-Length: 378 Content-Type: application/json ; charset = utf-8 Date: Fri, 12 Apr 2019 19 :57:49 GMT Server: Python/3.7 aiohttp/3.5.4 { \"invalid_params\" : [ { \"loc\" : [ \"body\" , \"name\" ] , \"msg\" : \"field required\" , \"type\" : \"value_error.missing\" } , { \"loc\" : [ \"body\" , \"age\" ] , \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } , { \"loc\" : [ \"path\" , \"user_id\" ] , \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] , \"title\" : \"Your request parameters didn't validate.\" , \"type\" : \"validation_error\" }","title":"Request Body"}]}